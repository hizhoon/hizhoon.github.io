---
layout: post
title:  "알고리즘과 자료구조"
categories: [ Coding ]
image: assets/images/study2/study2.png
---
안녕하세요. 지훈입니다.<br>오늘은 알고리즘과 자료구조를 왜 배워야 하는지와 간단한 개념에 대해 정리하겠습니다.

## 알고리즘과 자료구조의 중요성
### 1. 문제 해결하는 데 있어 알고리즘과 자료구조의 파악이 중요함
알고리즘은 주어진 문제를 해결하는 방법을 정의하고, 자료 구조는 데이터를 저장하고 조작하는 방법을 제공합니다. 이 둘을 알아야 코드에 문제가 생겼을 때, 더 효율적으로 해결할 수 있습니다. 효과적인 알고리즘을 선택하고 적절한 자료 구조를 사용하면 프로그램의 실행 속도와 메모리 사용량을 최적화할 수 있습니다.

같은 상황을 코딩하더라도, 더 효율적인 코드를 짜는 사람이 있습니다. 이런 분들이 알고리즘과 자료구조를 더 명확히 파악하고 있다고 볼 수 있습니다.

### 2. 프로그래밍 효율 개선
좋은 알고리즘과 자료 구조를 사용하면 프로그램의 효율성을 크게 향상시킬 수 있습니다. 예를 들어, 검색 알고리즘을 효과적으로 구현하면 대용량 데이터에서 원하는 정보를 빠르게 찾을 수 있습니다. 또한, 적절한 자료 구조를 선택하면 데이터를 효율적으로 저장하고 관리할 수 있습니다.

### 3. 시스템 설계에 필수
대규모 시스템을 설계할 때도 알고리즘과 자료 구조는 필수적입니다. 데이터베이스, 네트워크 시스템, 운영 체제 등 다양한 시스템에서는 효율적인 자료 구조와 알고리즘이 시스템의 성능을 크게 좌우합니다.

![라면 끓이는 순서도 알고리즘](../assets/images/study2/study2_1.jpg)

알고리즘을 쉽게 보여주는 라면 끓여주는 순서도를 가져와 봤습니다. 사진을 보면, 라면을 끓이는 데 있어 매우 효율적이죠? 이처럼, 효율적인 알고리즘이 맛있는 라면을 가져옵니다.

## 알고리즘
**알고리즘**은 어떤 문제를 해결하기 위한 단계적인 절차나 규칙의 집합을 의미합니다. 즉, 주어진 입력에 대해 원하는 출력을 얻기 위한 명확하고 효과적인 방법을 의미합니다. 

### 좋은 알고리즘이란?
좋은 알고리즘일수록, 더 좋은 코드라고 볼 수 있습니다. 그럼, 무엇이 좋은 알고리즘인지, 좋은 알고리즘이 가져야 할 3가지를 소개하겠습니다.

 - **효율성** : 좋은 알고리즘은 입력 데이터의 크기에 관계없이 일정한 시간 내에 원하는 결과를 도출할 수 있어야 합니다.
 - **가독성**: 알고리즘은 이해하기 쉬워야 하며, 코드로 구현될 때 가독성이 좋아야 합니다.
 - **정확성**: 알고리즘은 정확한 결과를 도출해야 하며, 입력값에 대해 일관된 출력을 생성해야 합니다.

### 알고리즘 종류
상황에 따라 적용하는 알고리즘이 다릅니다. 어떤 알고리즘을 써야 효율적일지 생각한 후, 신중히 골라야 합니다.
 - **탐색 알고리즘과 자료 구조** : 탐색 문제에서는 배열, 트리, 그래프 등 다양한 자료 구조를 활용하여 효율적인 탐색을 수행하는 알고리즘이 중요합니다.
 - **정렬 알고리즘과 자료 구조** : 정렬 문제에서는 배열 등의 자료 구조를 이용하여 데이터를 정렬하는 알고리즘이 필요합니다.
 - **그래프 알고리즘과 자료 구조** : 그래프 문제에서는 그래프를 나타내는 자료 구조와 그래프 탐색 알고리즘이 중요합니다.
 
## 자료 구조
 자료 구조는 데이터를 효율적으로 저장하고 조작하기 위한 방법이나 구조를 말합니다. 즉, 데이터의 조직화와 관리를 위한 체계를 제공합니다. 여러 가지 자료 구조 중에서도 배열, 연결 리스트, 스택, 큐, 트리, 해시 테이블 등이 널리 사용됩니다.

### 1. 배열(Array)
데이터를 일렬로 저장하는 자료 구조로, 인덱스를 사용하여 특정 위치의 값을 빠르게 접근할 수 있습니다.<br>배열 자료 구조를 선택하는 경우 : 데이터의 크기가 고정되어 있고, 인덱스를 통한 빠른 검색이 필요한 경우.
```
alphabet = ["A", "B", "C", "D"]
print(alphabet[2])
# 출력: C
```
### 2. 연결 리스트(Linked List)
노드들이 연결된 구조를 가지며, 삽입과 삭제가 배열에 비해 효율적입니다.<br>연결 리스트 자료 구조를 선택하는 경우 : 데이터의 크기가 동적으로 변하며, 중간 삽입 또는 삭제가 빈번한 경우.
```
class  Node:
	def  __init__(self, data):
		self.data = data
		self.next = None 

# 연결 리스트 생성: 1 -> 2 -> 3
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
```
### 3. 해시 테이블(Hash Table)
특정 키에 대한 값을 빠르게 찾을 수 있는 해싱 기법을 사용하는 자료 구조로, 검색이 매우 빠릅니다.<br>해시 테이블 자료 구조를 선택하는 경우 : 빠른 검색이 필요하며, 키-값 쌍으로 데이터를 저장하는 경우.
```
hash_table = {}
hash_table["a"] = 1
hash_table["b"] = 2
print(hash_table["a"])
# 출력: 1
```
### 스택(Stack)
Last-In, First-Out(LIFO)의 특성을 가진 자료 구조로, 스택은 데이터를 한쪽 끝에서만 삽입하고 삭제합니다. 스택 자료 구조를 선택하는 경우 : 함수 호출 시 호출 스택을 관리하는 경우.
```
stack = []
stack.append(1)
stack.append(2)
stack.pop()
# 출력: 2
```
### 큐(Queue)
First-In, First-Out(FIFO)의 특성을 가진 자료 구조로, 큐는 양쪽 끝에서 각각 삽입과 삭제가 이루어집니다. 큐 자료 구조를 선택하는 경우 : 작업 대기열을 관리하는 경우.
```
from collections import deque
queue = deque()
queue.append(1)
queue.append(2)
queue.popleft()
# 출력: 1
```

다음 포스팅은 아직 정하지는 않았지만, 금방 올 예정입니다.
